-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParLua where
import AbsLua
import LexLua
import ErrM

}

%name pProgram Program
%name pDec Dec
%name pStm Stm
%name pExp Exp
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '%' { PT _ (TS _ 1) }
  '%=' { PT _ (TS _ 2) }
  '&' { PT _ (TS _ 3) }
  '&=' { PT _ (TS _ 4) }
  '(' { PT _ (TS _ 5) }
  ')' { PT _ (TS _ 6) }
  '*' { PT _ (TS _ 7) }
  '*=' { PT _ (TS _ 8) }
  '+' { PT _ (TS _ 9) }
  '+=' { PT _ (TS _ 10) }
  ',' { PT _ (TS _ 11) }
  '-' { PT _ (TS _ 12) }
  '-=' { PT _ (TS _ 13) }
  '/' { PT _ (TS _ 14) }
  '/=' { PT _ (TS _ 15) }
  ':' { PT _ (TS _ 16) }
  '<' { PT _ (TS _ 17) }
  '<=' { PT _ (TS _ 18) }
  '=' { PT _ (TS _ 19) }
  '==' { PT _ (TS _ 20) }
  '>' { PT _ (TS _ 21) }
  '>=' { PT _ (TS _ 22) }
  '?' { PT _ (TS _ 23) }
  '^' { PT _ (TS _ 24) }
  '^=' { PT _ (TS _ 25) }
  '_' { PT _ (TS _ 26) }
  'and' { PT _ (TS _ 27) }
  'boolean' { PT _ (TS _ 28) }
  'catch' { PT _ (TS _ 29) }
  'character' { PT _ (TS _ 30) }
  'const' { PT _ (TS _ 31) }
  'do' { PT _ (TS _ 32) }
  'else' { PT _ (TS _ 33) }
  'end' { PT _ (TS _ 34) }
  'float' { PT _ (TS _ 35) }
  'for' { PT _ (TS _ 36) }
  'function' { PT _ (TS _ 37) }
  'if' { PT _ (TS _ 38) }
  'integer' { PT _ (TS _ 39) }
  'not' { PT _ (TS _ 40) }
  'or' { PT _ (TS _ 41) }
  'pointer' { PT _ (TS _ 42) }
  'ref' { PT _ (TS _ 43) }
  'repeat' { PT _ (TS _ 44) }
  'return' { PT _ (TS _ 45) }
  'string' { PT _ (TS _ 46) }
  'then' { PT _ (TS _ 47) }
  'try' { PT _ (TS _ 48) }
  'until' { PT _ (TS _ 49) }
  'val' { PT _ (TS _ 50) }
  'void' { PT _ (TS _ 51) }
  'while' { PT _ (TS _ 52) }
  '{' { PT _ (TS _ 53) }
  '{}' { PT _ (TS _ 54) }
  '|=' { PT _ (TS _ 55) }
  '}' { PT _ (TS _ 56) }
  '~=' { PT _ (TS _ 57) }

L_Pbreak { PT _ (T_Pbreak _) }
L_Pcontinue { PT _ (T_Pcontinue _) }
L_Pbool { PT _ (T_Pbool _) }
L_Pident { PT _ (T_Pident _) }
L_Pint { PT _ (T_Pint _) }
L_Pstring { PT _ (T_Pstring _) }
L_Preal { PT _ (T_Preal _) }
L_Pchar { PT _ (T_Pchar _) }

%left ASS
%left EXP
%left EXPINLEXP
%left IDLEXP
%left CALL
%nonassoc TERN '?'
%left 'not'
%left 'or' 'and'
%right '('
%right ')'
%right '{'
%nonassoc '==' '~=' '<' '<=' '>' '>=' '='
%left '+' '-'
%left '*' '/' '%'
%left '^' 
%right REF  '&'
%left NEG
%nonassoc '++' '--'
%nonassoc UNTIL RET IFELSE
%left PARLEXP



%%

Pbreak    :: { Pbreak} : L_Pbreak { Pbreak (mkPosToken $1)}
Pcontinue   :: { Pcontinue} : L_Pcontinue { Pcontinue (mkPosToken $1)}
Pident    :: {Pident} : L_Pident { Pident (mkPosToken $1)}
Pint    :: {Pint} : L_Pint { Pint (mkPosToken $1)}
Pbool    :: {Pbool} : L_Pbool { Pbool (mkPosToken $1)}
Pstring    :: {Pstring} : L_Pstring { Pstring (mkPosToken $1)}
Preal    :: {Preal} : L_Preal { Preal (mkPosToken $1)}
Pchar    :: {Pchar} : L_Pchar { Pchar (mkPosToken $1)}


Program :: { Program }
Program : ListDec {Progr (reverse $1)}
ListDec :: { [Dec] }
ListDec : {- empty -} { [] } | ListDec Dec { flip (:) $1 $2 }
Dec :: { Dec }
Dec : 'function' Type_specifier Pident '('ListArgument')'ListDecStm 'end' { Func $2 $3 $5 (length $5)  (reverse $7) }
    |'function' Pident '('ListArgument')'ListDecStm 'end' { Func Tvoid $2 $4 (length $4) (reverse $6) }
    | Type_specifier Pident {VarDeclar Nothing $1 $2 Nothing}
    | 'const' Type_specifier Pident {VarDeclar (Just Modality_CONST) $2 $3 Nothing}
    | Type_specifier Pident '=' Exp { VarDeclar Nothing $1 $2 (Just $4) }
    | 'const' Type_specifier Pident '=' Exp { VarDeclar (Just Modality_CONST) $2 $3 (Just $5)}
Type_specifier :: { Type_specifier }
Type_specifier :'boolean' { Tbool }
          | 'character' { Tchar }
          | 'float' { Tfloat }
          | 'integer' { Tint }
          | 'string' { Tstring }
          | 'void'{ Tvoid }
          | 'pointer' Type_specifier { Tpointer $2 }
          | '{}' Type_specifier { Tarray Nothing $2 }
          | '{'Exp'}' Type_specifier { Tarray (Just $2) $4 } 
Argument :: { Argument }
Argument : Modality Type_specifier Pident { FormPar $1 $2 $3 }
ListArgument :: { [Argument] }
ListArgument : {- empty -} { [] }
              | Argument { (:[]) $1 }
              | Argument ',' ListArgument { (:) $1 $3 }
Modality :: { Modality }
Modality : {- empty -} {  Modality_VAL }
         | 'val' { Modality_VAL }
         | 'const' { Modality_CONST }
         | 'ref' { Modality_REF }
Stm :: { Stm }
Stm : Lexp Assignment_Op Exp %prec ASS {Assgn $2 $1 $3 }
    | 'return' Exp %prec RET { Valreturn $2 }
    |  Exp %prec EXP { SExp $1 }
    | 'if' Exp 'then' ListDecStm 'end' {SimpleIf $2 (reverse $4) }
    | 'if' Exp 'then' ListDecStm 'else' ListDecStm 'end' %prec IFELSE { IfThElse $2 (reverse $4) (reverse $6) }
    | 'while' Exp 'do' ListDecStm 'end' { While $2 (reverse $4) }
    | 'repeat' ListDecStm 'until' Exp %prec UNTIL { RepeatUntil (reverse $2) $4 }
    | 'for' Pident '=' Exp ',' Exp ',' Exp 'do' ListDecStm 'end' { For $2 $4 $6 $8 (reverse $10)}
    | 'try' ListDecStm 'catch' ListDecStm 'end' { TryCatch (reverse $2) (reverse $4) } 
    | Pbreak {Break $1}
    | Pcontinue {Continue $1}

DecStm :: { DecStm }
DecStm : Dec { Dec $1 } | Stm { Stmt $1 }

ListDecStm :: { [DecStm] }
ListDecStm : {- empty -} { [] }
           | ListDecStm DecStm { flip (:) $1 $2 }

Exp :: { Exp }
Exp : Pident '(' ListExp ')' %prec CALL { Fcall $1 $3 (length $3) }
     |'('Exp')' {$2}
     |Exp 'or' Exp {InfixOp (BoolOp Or) $1 $3 }
     |Exp 'and' Exp { InfixOp (BoolOp And) $1 $3 }
     |Exp '==' Exp { InfixOp (RelOp Eq) $1 $3 }
     |Exp '~=' Exp { InfixOp (RelOp Neq) $1 $3 }
     |Exp '<' Exp { InfixOp (RelOp Lt) $1 $3 }
     |Exp '>' Exp { InfixOp (RelOp Gt) $1 $3 }
     |Exp '<=' Exp { InfixOp (RelOp LtE) $1 $3 }
     |Exp '>=' Exp { InfixOp (RelOp GtE) $1 $3 }
     |Exp '+' Exp { InfixOp (ArithOp Add) $1 $3 }
     |Exp '-' Exp { InfixOp (ArithOp Sub)$1 $3 }
     |Exp '*' Exp {InfixOp (ArithOp Mul) $1 $3 }
     |Exp '/' Exp {InfixOp (ArithOp Div) $1 $3 }
     |Exp '^' Exp {InfixOp (ArithOp Pow) $1 $3 }
     |Exp '%' Exp {InfixOp (ArithOp Mod)$1 $3 }
     |Exp '?' Exp ':' Exp %prec TERN { TernaryOp $1 $3 $5 }
     |'&' Exp  { Addr $2 } --credo sia lexp
     | '-' Exp %prec NEG { Unary_Op Neg $2}
     | 'not' Exp { Unary_Op Logneg $2 }
     |'{' ListExp '}' { Arr $2 }
     | Lexp %prec EXPINLEXP { $1 }
     | Preal { Efloat $1 }
     | Pint  { Eint $1 }
     | Pbool { Ebool $1 }
     | Pstring { Estring $1 }
     | Pchar { Echar $1 }

ListExp :: { [Exp] }
ListExp : {- empty -} { [] }
         | Exp { (:[]) $1 }
         | Exp ',' ListExp { (:) $1 $3 }

Lexp :: { Exp }
Lexp :  Pident %prec IDLEXP { Evar $1 } 
     | '('Lexp')' %prec PARLEXP {$2} 
     | '_' Exp %prec REF  { Indirection $2 } 
     | Lexp '{' Exp '}' { Arraysel $1 $3 }
Assignment_Op :: { Assignment_Op }
Assignment_Op : '=' { Assign }
              | '*=' { AssgnArith Mul }
              | '/=' { AssgnArith Div }
              | '%=' { AssgnArith Mod }
              | '+=' { AssgnArith Add }
              | '-=' { AssgnArith Sub }
              | '^=' { AssgnArith Pow }
              | '&=' { AssgnBool And }
              | '|=' { AssgnBool Or}
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

